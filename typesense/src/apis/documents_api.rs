// Typesense API
//
// An open source search engine for building delightful search experiences.
//
// The version of the OpenAPI document: 27.0
//
// Generated by: https://openapi-generator.tech

use std::sync::Arc;

use async_trait::async_trait;
use reqwest;
use serde::{Deserialize, Serialize};

use super::{configuration, Error};
use crate::apis::ResponseContent;
use crate::models;

#[async_trait]
pub trait DocumentsApi: Send + Sync {
	async fn delete_document(&self, params: DeleteDocumentParams) -> Result<serde_json::Value, Error<DeleteDocumentError>>;
	async fn delete_documents(
		&self,
		params: DeleteDocumentsParams,
	) -> Result<models::DeleteDocuments200Response, Error<DeleteDocumentsError>>;
	async fn delete_search_override(
		&self,
		params: DeleteSearchOverrideParams,
	) -> Result<models::SearchOverride, Error<DeleteSearchOverrideError>>;
	async fn delete_search_synonym(
		&self,
		params: DeleteSearchSynonymParams,
	) -> Result<models::SearchSynonym, Error<DeleteSearchSynonymError>>;
	async fn export_documents(&self, params: ExportDocumentsParams) -> Result<String, Error<ExportDocumentsError>>;
	async fn get_document(&self, params: GetDocumentParams) -> Result<serde_json::Value, Error<GetDocumentError>>;
	async fn get_search_override(
		&self,
		params: GetSearchOverrideParams,
	) -> Result<models::SearchOverride, Error<GetSearchOverrideError>>;
	async fn get_search_overrides(
		&self,
		params: GetSearchOverridesParams,
	) -> Result<models::SearchOverridesResponse, Error<GetSearchOverridesError>>;
	async fn get_search_synonym(
		&self,
		params: GetSearchSynonymParams,
	) -> Result<models::SearchSynonym, Error<GetSearchSynonymError>>;
	async fn get_search_synonyms(
		&self,
		params: GetSearchSynonymsParams,
	) -> Result<models::SearchSynonymsResponse, Error<GetSearchSynonymsError>>;
	async fn import_documents(&self, params: ImportDocumentsParams) -> Result<String, Error<ImportDocumentsError>>;
	async fn index_document(&self, params: IndexDocumentParams) -> Result<serde_json::Value, Error<IndexDocumentError>>;
	async fn multi_search(&self, params: MultiSearchParams) -> Result<models::MultiSearchResult, Error<MultiSearchError>>;
	async fn search_collection(
		&self,
		params: SearchCollectionParams,
	) -> Result<models::SearchResult, Error<SearchCollectionError>>;
	async fn update_document(&self, params: UpdateDocumentParams) -> Result<serde_json::Value, Error<UpdateDocumentError>>;
	async fn update_documents(
		&self,
		params: UpdateDocumentsParams,
	) -> Result<models::UpdateDocuments200Response, Error<UpdateDocumentsError>>;
	async fn upsert_search_override(
		&self,
		params: UpsertSearchOverrideParams,
	) -> Result<models::SearchOverride, Error<UpsertSearchOverrideError>>;
	async fn upsert_search_synonym(
		&self,
		params: UpsertSearchSynonymParams,
	) -> Result<models::SearchSynonym, Error<UpsertSearchSynonymError>>;
}

pub struct DocumentsApiClient {
	configuration: Arc<configuration::Configuration>,
}

impl DocumentsApiClient {
	pub fn new(configuration: Arc<configuration::Configuration>) -> Self {
		Self { configuration }
	}
}

/// struct for passing parameters to the method [`delete_document`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteDocumentParams {
	/// The name of the collection to search for the document under
	pub collection_name: String,
	/// The Document ID
	pub document_id: String,
}

/// struct for passing parameters to the method [`delete_documents`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteDocumentsParams {
	/// The name of the collection to delete documents from
	pub collection_name: String,
	pub filter_by: String,
	pub batch_size: Option<i32>,
	pub ignore_not_found: Option<bool>,
}

/// struct for passing parameters to the method [`delete_search_override`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteSearchOverrideParams {
	/// The name of the collection
	pub collection_name: String,
	/// The ID of the search override to delete
	pub override_id: String,
}

/// struct for passing parameters to the method [`delete_search_synonym`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct DeleteSearchSynonymParams {
	/// The name of the collection
	pub collection_name: String,
	/// The ID of the search synonym to delete
	pub synonym_id: String,
}

/// struct for passing parameters to the method [`export_documents`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ExportDocumentsParams {
	/// The name of the collection
	pub collection_name: String,
	pub filter_by: Option<String>,
	pub include_fields: Option<String>,
	pub exclude_fields: Option<String>,
}

/// struct for passing parameters to the method [`get_document`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetDocumentParams {
	/// The name of the collection to search for the document under
	pub collection_name: String,
	/// The Document ID
	pub document_id: String,
}

/// struct for passing parameters to the method [`get_search_override`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetSearchOverrideParams {
	/// The name of the collection
	pub collection_name: String,
	/// The id of the search override
	pub override_id: String,
}

/// struct for passing parameters to the method [`get_search_overrides`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetSearchOverridesParams {
	/// The name of the collection
	pub collection_name: String,
}

/// struct for passing parameters to the method [`get_search_synonym`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetSearchSynonymParams {
	/// The name of the collection
	pub collection_name: String,
	/// The id of the search synonym
	pub synonym_id: String,
}

/// struct for passing parameters to the method [`get_search_synonyms`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetSearchSynonymsParams {
	/// The name of the collection
	pub collection_name: String,
}

/// struct for passing parameters to the method [`import_documents`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct ImportDocumentsParams {
	/// The name of the collection
	pub collection_name: String,
	/// The json array of documents or the JSONL file to import
	pub body: String,
	pub batch_size: Option<i32>,
	pub return_id: Option<bool>,
	pub remote_embedding_batch_size: Option<i32>,
	pub return_doc: Option<bool>,
	pub action: Option<models::IndexAction>,
	pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`index_document`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct IndexDocumentParams {
	/// The name of the collection to add the document to
	pub collection_name: String,
	/// The document object to be indexed
	pub body: serde_json::Value,
	/// Additional action to perform
	pub action: Option<String>,
	/// Dealing with Dirty Data
	pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`multi_search`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct MultiSearchParams {
	pub q: Option<String>,
	pub query_by: Option<String>,
	pub query_by_weights: Option<String>,
	pub text_match_type: Option<String>,
	pub prefix: Option<String>,
	pub infix: Option<String>,
	pub max_extra_prefix: Option<i32>,
	pub max_extra_suffix: Option<i32>,
	pub filter_by: Option<String>,
	pub sort_by: Option<String>,
	pub facet_by: Option<String>,
	pub max_facet_values: Option<i32>,
	pub facet_query: Option<String>,
	pub num_typos: Option<String>,
	pub page: Option<i32>,
	pub per_page: Option<i32>,
	pub limit: Option<i32>,
	pub offset: Option<i32>,
	pub group_by: Option<String>,
	pub group_limit: Option<i32>,
	pub group_missing_values: Option<bool>,
	pub include_fields: Option<String>,
	pub exclude_fields: Option<String>,
	pub highlight_full_fields: Option<String>,
	pub highlight_affix_num_tokens: Option<i32>,
	pub highlight_start_tag: Option<String>,
	pub highlight_end_tag: Option<String>,
	pub snippet_threshold: Option<i32>,
	pub drop_tokens_threshold: Option<i32>,
	pub drop_tokens_mode: Option<models::DropTokensMode>,
	pub typo_tokens_threshold: Option<i32>,
	pub enable_typos_for_alpha_numerical_tokens: Option<bool>,
	pub filter_curated_hits: Option<bool>,
	pub enable_synonyms: Option<bool>,
	pub synonym_prefix: Option<bool>,
	pub synonym_num_typos: Option<i32>,
	pub pinned_hits: Option<String>,
	pub hidden_hits: Option<String>,
	pub override_tags: Option<String>,
	pub highlight_fields: Option<String>,
	pub pre_segmented_query: Option<bool>,
	pub preset: Option<String>,
	pub enable_overrides: Option<bool>,
	pub prioritize_exact_match: Option<bool>,
	pub prioritize_token_position: Option<bool>,
	pub prioritize_num_matching_fields: Option<bool>,
	pub enable_typos_for_numerical_tokens: Option<bool>,
	pub exhaustive_search: Option<bool>,
	pub search_cutoff_ms: Option<i32>,
	pub use_cache: Option<bool>,
	pub cache_ttl: Option<i32>,
	pub min_len_1typo: Option<i32>,
	pub min_len_2typo: Option<i32>,
	pub vector_query: Option<String>,
	pub remote_embedding_timeout_ms: Option<i32>,
	pub remote_embedding_num_tries: Option<i32>,
	pub facet_strategy: Option<String>,
	pub stopwords: Option<String>,
	pub facet_return_parent: Option<String>,
	pub voice_query: Option<String>,
	pub conversation: Option<bool>,
	pub conversation_model_id: Option<String>,
	pub conversation_id: Option<String>,
	pub multi_search_searches_parameter: Option<models::MultiSearchSearchesParameter>,
}

/// struct for passing parameters to the method [`search_collection`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct SearchCollectionParams {
	/// The name of the collection to search for the document under
	pub collection_name: String,
	pub q: String,
	pub query_by: String,
	pub query_by_weights: Option<String>,
	pub text_match_type: Option<String>,
	pub prefix: Option<String>,
	pub infix: Option<String>,
	pub max_extra_prefix: Option<i32>,
	pub max_extra_suffix: Option<i32>,
	pub filter_by: Option<String>,
	pub sort_by: Option<String>,
	pub facet_by: Option<String>,
	pub max_facet_values: Option<i32>,
	pub facet_query: Option<String>,
	pub num_typos: Option<String>,
	pub page: Option<i32>,
	pub per_page: Option<i32>,
	pub limit: Option<i32>,
	pub offset: Option<i32>,
	pub group_by: Option<String>,
	pub group_limit: Option<i32>,
	pub group_missing_values: Option<bool>,
	pub include_fields: Option<String>,
	pub exclude_fields: Option<String>,
	pub highlight_full_fields: Option<String>,
	pub highlight_affix_num_tokens: Option<i32>,
	pub highlight_start_tag: Option<String>,
	pub highlight_end_tag: Option<String>,
	pub enable_highlight_v1: Option<bool>,
	pub snippet_threshold: Option<i32>,
	pub drop_tokens_threshold: Option<i32>,
	pub drop_tokens_mode: Option<models::DropTokensMode>,
	pub typo_tokens_threshold: Option<i32>,
	pub enable_typos_for_alpha_numerical_tokens: Option<bool>,
	pub filter_curated_hits: Option<bool>,
	pub enable_synonyms: Option<bool>,
	pub synonym_prefix: Option<bool>,
	pub synonym_num_typos: Option<i32>,
	pub pinned_hits: Option<String>,
	pub hidden_hits: Option<String>,
	pub override_tags: Option<String>,
	pub highlight_fields: Option<String>,
	pub split_join_tokens: Option<String>,
	pub pre_segmented_query: Option<bool>,
	pub preset: Option<String>,
	pub enable_overrides: Option<bool>,
	pub prioritize_exact_match: Option<bool>,
	pub max_candidates: Option<i32>,
	pub prioritize_token_position: Option<bool>,
	pub prioritize_num_matching_fields: Option<bool>,
	pub enable_typos_for_numerical_tokens: Option<bool>,
	pub exhaustive_search: Option<bool>,
	pub search_cutoff_ms: Option<i32>,
	pub use_cache: Option<bool>,
	pub cache_ttl: Option<i32>,
	pub min_len_1typo: Option<i32>,
	pub min_len_2typo: Option<i32>,
	pub vector_query: Option<String>,
	pub remote_embedding_timeout_ms: Option<i32>,
	pub remote_embedding_num_tries: Option<i32>,
	pub facet_strategy: Option<String>,
	pub stopwords: Option<String>,
	pub facet_return_parent: Option<String>,
	pub voice_query: Option<String>,
	pub conversation: Option<bool>,
	pub conversation_model_id: Option<String>,
	pub conversation_id: Option<String>,
}

/// struct for passing parameters to the method [`update_document`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateDocumentParams {
	/// The name of the collection to search for the document under
	pub collection_name: String,
	/// The Document ID
	pub document_id: String,
	/// The document object with fields to be updated
	pub body: serde_json::Value,
	/// Dealing with Dirty Data
	pub dirty_values: Option<models::DirtyValues>,
}

/// struct for passing parameters to the method [`update_documents`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpdateDocumentsParams {
	/// The name of the collection to update documents in
	pub collection_name: String,
	/// The document fields to be updated
	pub body: serde_json::Value,
	pub filter_by: Option<String>,
}

/// struct for passing parameters to the method [`upsert_search_override`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpsertSearchOverrideParams {
	/// The name of the collection
	pub collection_name: String,
	/// The ID of the search override to create/update
	pub override_id: String,
	/// The search override object to be created/updated
	pub search_override_schema: models::SearchOverrideSchema,
}

/// struct for passing parameters to the method [`upsert_search_synonym`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct UpsertSearchSynonymParams {
	/// The name of the collection
	pub collection_name: String,
	/// The ID of the search synonym to create/update
	pub synonym_id: String,
	/// The search synonym object to be created/updated
	pub search_synonym_schema: models::SearchSynonymSchema,
}

#[async_trait]
impl DocumentsApi for DocumentsApiClient {
	/// Delete an individual document from a collection by using its ID.
	async fn delete_document(&self, params: DeleteDocumentParams) -> Result<serde_json::Value, Error<DeleteDocumentError>> {
		let DeleteDocumentParams {
			collection_name,
			document_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents/{documentId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			documentId = crate::apis::urlencode(document_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteDocumentError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Delete a bunch of documents that match a specific filter condition. Use
	/// the `batch_size` parameter to control the number of documents that
	/// should deleted at a time. A larger value will speed up deletions, but
	/// will impact performance of other operations running on the server.
	async fn delete_documents(
		&self,
		params: DeleteDocumentsParams,
	) -> Result<models::DeleteDocuments200Response, Error<DeleteDocumentsError>> {
		let DeleteDocumentsParams {
			collection_name,
			filter_by,
			batch_size,
			ignore_not_found,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		local_var_req_builder = local_var_req_builder.query(&[("filter_by", &filter_by.to_string())]);
		if let Some(ref local_var_str) = batch_size {
			local_var_req_builder = local_var_req_builder.query(&[("batch_size", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = ignore_not_found {
			local_var_req_builder = local_var_req_builder.query(&[("ignore_not_found", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteDocumentsError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	async fn delete_search_override(
		&self,
		params: DeleteSearchOverrideParams,
	) -> Result<models::SearchOverride, Error<DeleteSearchOverrideError>> {
		let DeleteSearchOverrideParams {
			collection_name,
			override_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/overrides/{overrideId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			overrideId = crate::apis::urlencode(override_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteSearchOverrideError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	async fn delete_search_synonym(
		&self,
		params: DeleteSearchSynonymParams,
	) -> Result<models::SearchSynonym, Error<DeleteSearchSynonymError>> {
		let DeleteSearchSynonymParams {
			collection_name,
			synonym_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/synonyms/{synonymId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			synonymId = crate::apis::urlencode(synonym_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<DeleteSearchSynonymError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Export all documents in a collection in JSON lines format.
	async fn export_documents(&self, params: ExportDocumentsParams) -> Result<String, Error<ExportDocumentsError>> {
		let ExportDocumentsParams {
			collection_name,
			filter_by,
			include_fields,
			exclude_fields,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents/export",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = filter_by {
			local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = include_fields {
			local_var_req_builder = local_var_req_builder.query(&[("include_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = exclude_fields {
			local_var_req_builder = local_var_req_builder.query(&[("exclude_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ExportDocumentsError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Fetch an individual document from a collection by using its ID.
	async fn get_document(&self, params: GetDocumentParams) -> Result<serde_json::Value, Error<GetDocumentError>> {
		let GetDocumentParams {
			collection_name,
			document_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents/{documentId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			documentId = crate::apis::urlencode(document_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetDocumentError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Retrieve the details of a search override, given its id.
	async fn get_search_override(
		&self,
		params: GetSearchOverrideParams,
	) -> Result<models::SearchOverride, Error<GetSearchOverrideError>> {
		let GetSearchOverrideParams {
			collection_name,
			override_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/overrides/{overrideId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			overrideId = crate::apis::urlencode(override_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetSearchOverrideError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	async fn get_search_overrides(
		&self,
		params: GetSearchOverridesParams,
	) -> Result<models::SearchOverridesResponse, Error<GetSearchOverridesError>> {
		let GetSearchOverridesParams { collection_name } = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/overrides",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetSearchOverridesError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Retrieve the details of a search synonym, given its id.
	async fn get_search_synonym(
		&self,
		params: GetSearchSynonymParams,
	) -> Result<models::SearchSynonym, Error<GetSearchSynonymError>> {
		let GetSearchSynonymParams {
			collection_name,
			synonym_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/synonyms/{synonymId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			synonymId = crate::apis::urlencode(synonym_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetSearchSynonymError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	async fn get_search_synonyms(
		&self,
		params: GetSearchSynonymsParams,
	) -> Result<models::SearchSynonymsResponse, Error<GetSearchSynonymsError>> {
		let GetSearchSynonymsParams { collection_name } = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/synonyms",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<GetSearchSynonymsError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// The documents to be imported must be formatted in a newline delimited
	/// JSON structure. You can feed the output file from a Typesense export
	/// operation directly as import.
	async fn import_documents(&self, params: ImportDocumentsParams) -> Result<String, Error<ImportDocumentsError>> {
		let ImportDocumentsParams {
			collection_name,
			body,
			batch_size,
			return_id,
			remote_embedding_batch_size,
			return_doc,
			action,
			dirty_values,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents/import",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = batch_size {
			local_var_req_builder = local_var_req_builder.query(&[("batch_size", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = return_id {
			local_var_req_builder = local_var_req_builder.query(&[("return_id", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = remote_embedding_batch_size {
			local_var_req_builder =
				local_var_req_builder.query(&[("remote_embedding_batch_size", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = return_doc {
			local_var_req_builder = local_var_req_builder.query(&[("return_doc", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = action {
			local_var_req_builder = local_var_req_builder.query(&[("action", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = dirty_values {
			local_var_req_builder = local_var_req_builder.query(&[("dirty_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&body);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<ImportDocumentsError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// A document to be indexed in a given collection must conform to the
	/// schema of the collection.
	async fn index_document(&self, params: IndexDocumentParams) -> Result<serde_json::Value, Error<IndexDocumentError>> {
		let IndexDocumentParams {
			collection_name,
			body,
			action,
			dirty_values,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = action {
			local_var_req_builder = local_var_req_builder.query(&[("action", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = dirty_values {
			local_var_req_builder = local_var_req_builder.query(&[("dirty_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&body);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<IndexDocumentError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// This is especially useful to avoid round-trip network latencies incurred
	/// otherwise if each of these requests are sent in separate HTTP requests.
	/// You can also use this feature to do a federated search across multiple
	/// collections in a single HTTP request.
	async fn multi_search(&self, params: MultiSearchParams) -> Result<models::MultiSearchResult, Error<MultiSearchError>> {
		let MultiSearchParams {
			q,
			query_by,
			query_by_weights,
			text_match_type,
			prefix,
			infix,
			max_extra_prefix,
			max_extra_suffix,
			filter_by,
			sort_by,
			facet_by,
			max_facet_values,
			facet_query,
			num_typos,
			page,
			per_page,
			limit,
			offset,
			group_by,
			group_limit,
			group_missing_values,
			include_fields,
			exclude_fields,
			highlight_full_fields,
			highlight_affix_num_tokens,
			highlight_start_tag,
			highlight_end_tag,
			snippet_threshold,
			drop_tokens_threshold,
			drop_tokens_mode,
			typo_tokens_threshold,
			enable_typos_for_alpha_numerical_tokens,
			filter_curated_hits,
			enable_synonyms,
			synonym_prefix,
			synonym_num_typos,
			pinned_hits,
			hidden_hits,
			override_tags,
			highlight_fields,
			pre_segmented_query,
			preset,
			enable_overrides,
			prioritize_exact_match,
			prioritize_token_position,
			prioritize_num_matching_fields,
			enable_typos_for_numerical_tokens,
			exhaustive_search,
			search_cutoff_ms,
			use_cache,
			cache_ttl,
			min_len_1typo,
			min_len_2typo,
			vector_query,
			remote_embedding_timeout_ms,
			remote_embedding_num_tries,
			facet_strategy,
			stopwords,
			facet_return_parent,
			voice_query,
			conversation,
			conversation_model_id,
			conversation_id,
			multi_search_searches_parameter,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!("{}/multi_search", local_var_configuration.base_path);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = q {
			local_var_req_builder = local_var_req_builder.query(&[("q", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = query_by {
			local_var_req_builder = local_var_req_builder.query(&[("query_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = query_by_weights {
			local_var_req_builder = local_var_req_builder.query(&[("query_by_weights", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = text_match_type {
			local_var_req_builder = local_var_req_builder.query(&[("text_match_type", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prefix {
			local_var_req_builder = local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = infix {
			local_var_req_builder = local_var_req_builder.query(&[("infix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_extra_prefix {
			local_var_req_builder = local_var_req_builder.query(&[("max_extra_prefix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_extra_suffix {
			local_var_req_builder = local_var_req_builder.query(&[("max_extra_suffix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = filter_by {
			local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = sort_by {
			local_var_req_builder = local_var_req_builder.query(&[("sort_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_by {
			local_var_req_builder = local_var_req_builder.query(&[("facet_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_facet_values {
			local_var_req_builder = local_var_req_builder.query(&[("max_facet_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_query {
			local_var_req_builder = local_var_req_builder.query(&[("facet_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = num_typos {
			local_var_req_builder = local_var_req_builder.query(&[("num_typos", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = page {
			local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = per_page {
			local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = limit {
			local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = offset {
			local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = group_by {
			local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = group_limit {
			local_var_req_builder = local_var_req_builder.query(&[("group_limit", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = group_missing_values {
			local_var_req_builder = local_var_req_builder.query(&[("group_missing_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = include_fields {
			local_var_req_builder = local_var_req_builder.query(&[("include_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = exclude_fields {
			local_var_req_builder = local_var_req_builder.query(&[("exclude_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_full_fields {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_full_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_affix_num_tokens {
			local_var_req_builder =
				local_var_req_builder.query(&[("highlight_affix_num_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_start_tag {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_start_tag", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_end_tag {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_end_tag", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = snippet_threshold {
			local_var_req_builder = local_var_req_builder.query(&[("snippet_threshold", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = drop_tokens_threshold {
			local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_threshold", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = drop_tokens_mode {
			local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_mode", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = typo_tokens_threshold {
			local_var_req_builder = local_var_req_builder.query(&[("typo_tokens_threshold", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_typos_for_alpha_numerical_tokens {
			local_var_req_builder =
				local_var_req_builder.query(&[("enable_typos_for_alpha_numerical_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = filter_curated_hits {
			local_var_req_builder = local_var_req_builder.query(&[("filter_curated_hits", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_synonyms {
			local_var_req_builder = local_var_req_builder.query(&[("enable_synonyms", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = synonym_prefix {
			local_var_req_builder = local_var_req_builder.query(&[("synonym_prefix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = synonym_num_typos {
			local_var_req_builder = local_var_req_builder.query(&[("synonym_num_typos", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = pinned_hits {
			local_var_req_builder = local_var_req_builder.query(&[("pinned_hits", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = hidden_hits {
			local_var_req_builder = local_var_req_builder.query(&[("hidden_hits", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = override_tags {
			local_var_req_builder = local_var_req_builder.query(&[("override_tags", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_fields {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = pre_segmented_query {
			local_var_req_builder = local_var_req_builder.query(&[("pre_segmented_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = preset {
			local_var_req_builder = local_var_req_builder.query(&[("preset", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_overrides {
			local_var_req_builder = local_var_req_builder.query(&[("enable_overrides", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prioritize_exact_match {
			local_var_req_builder = local_var_req_builder.query(&[("prioritize_exact_match", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prioritize_token_position {
			local_var_req_builder =
				local_var_req_builder.query(&[("prioritize_token_position", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prioritize_num_matching_fields {
			local_var_req_builder =
				local_var_req_builder.query(&[("prioritize_num_matching_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_typos_for_numerical_tokens {
			local_var_req_builder =
				local_var_req_builder.query(&[("enable_typos_for_numerical_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = exhaustive_search {
			local_var_req_builder = local_var_req_builder.query(&[("exhaustive_search", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = search_cutoff_ms {
			local_var_req_builder = local_var_req_builder.query(&[("search_cutoff_ms", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = use_cache {
			local_var_req_builder = local_var_req_builder.query(&[("use_cache", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = cache_ttl {
			local_var_req_builder = local_var_req_builder.query(&[("cache_ttl", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = min_len_1typo {
			local_var_req_builder = local_var_req_builder.query(&[("min_len_1typo", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = min_len_2typo {
			local_var_req_builder = local_var_req_builder.query(&[("min_len_2typo", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = vector_query {
			local_var_req_builder = local_var_req_builder.query(&[("vector_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = remote_embedding_timeout_ms {
			local_var_req_builder =
				local_var_req_builder.query(&[("remote_embedding_timeout_ms", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = remote_embedding_num_tries {
			local_var_req_builder =
				local_var_req_builder.query(&[("remote_embedding_num_tries", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_strategy {
			local_var_req_builder = local_var_req_builder.query(&[("facet_strategy", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = stopwords {
			local_var_req_builder = local_var_req_builder.query(&[("stopwords", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_return_parent {
			local_var_req_builder = local_var_req_builder.query(&[("facet_return_parent", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = voice_query {
			local_var_req_builder = local_var_req_builder.query(&[("voice_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = conversation {
			local_var_req_builder = local_var_req_builder.query(&[("conversation", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = conversation_model_id {
			local_var_req_builder = local_var_req_builder.query(&[("conversation_model_id", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = conversation_id {
			local_var_req_builder = local_var_req_builder.query(&[("conversation_id", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&multi_search_searches_parameter);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<MultiSearchError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Search for documents in a collection that match the search criteria.
	async fn search_collection(
		&self,
		params: SearchCollectionParams,
	) -> Result<models::SearchResult, Error<SearchCollectionError>> {
		let SearchCollectionParams {
			collection_name,
			q,
			query_by,
			query_by_weights,
			text_match_type,
			prefix,
			infix,
			max_extra_prefix,
			max_extra_suffix,
			filter_by,
			sort_by,
			facet_by,
			max_facet_values,
			facet_query,
			num_typos,
			page,
			per_page,
			limit,
			offset,
			group_by,
			group_limit,
			group_missing_values,
			include_fields,
			exclude_fields,
			highlight_full_fields,
			highlight_affix_num_tokens,
			highlight_start_tag,
			highlight_end_tag,
			enable_highlight_v1,
			snippet_threshold,
			drop_tokens_threshold,
			drop_tokens_mode,
			typo_tokens_threshold,
			enable_typos_for_alpha_numerical_tokens,
			filter_curated_hits,
			enable_synonyms,
			synonym_prefix,
			synonym_num_typos,
			pinned_hits,
			hidden_hits,
			override_tags,
			highlight_fields,
			split_join_tokens,
			pre_segmented_query,
			preset,
			enable_overrides,
			prioritize_exact_match,
			max_candidates,
			prioritize_token_position,
			prioritize_num_matching_fields,
			enable_typos_for_numerical_tokens,
			exhaustive_search,
			search_cutoff_ms,
			use_cache,
			cache_ttl,
			min_len_1typo,
			min_len_2typo,
			vector_query,
			remote_embedding_timeout_ms,
			remote_embedding_num_tries,
			facet_strategy,
			stopwords,
			facet_return_parent,
			voice_query,
			conversation,
			conversation_model_id,
			conversation_id,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents/search",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

		local_var_req_builder = local_var_req_builder.query(&[("q", &q.to_string())]);
		local_var_req_builder = local_var_req_builder.query(&[("query_by", &query_by.to_string())]);
		if let Some(ref local_var_str) = query_by_weights {
			local_var_req_builder = local_var_req_builder.query(&[("query_by_weights", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = text_match_type {
			local_var_req_builder = local_var_req_builder.query(&[("text_match_type", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prefix {
			local_var_req_builder = local_var_req_builder.query(&[("prefix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = infix {
			local_var_req_builder = local_var_req_builder.query(&[("infix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_extra_prefix {
			local_var_req_builder = local_var_req_builder.query(&[("max_extra_prefix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_extra_suffix {
			local_var_req_builder = local_var_req_builder.query(&[("max_extra_suffix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = filter_by {
			local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = sort_by {
			local_var_req_builder = local_var_req_builder.query(&[("sort_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_by {
			local_var_req_builder = local_var_req_builder.query(&[("facet_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_facet_values {
			local_var_req_builder = local_var_req_builder.query(&[("max_facet_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_query {
			local_var_req_builder = local_var_req_builder.query(&[("facet_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = num_typos {
			local_var_req_builder = local_var_req_builder.query(&[("num_typos", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = page {
			local_var_req_builder = local_var_req_builder.query(&[("page", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = per_page {
			local_var_req_builder = local_var_req_builder.query(&[("per_page", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = limit {
			local_var_req_builder = local_var_req_builder.query(&[("limit", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = offset {
			local_var_req_builder = local_var_req_builder.query(&[("offset", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = group_by {
			local_var_req_builder = local_var_req_builder.query(&[("group_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = group_limit {
			local_var_req_builder = local_var_req_builder.query(&[("group_limit", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = group_missing_values {
			local_var_req_builder = local_var_req_builder.query(&[("group_missing_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = include_fields {
			local_var_req_builder = local_var_req_builder.query(&[("include_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = exclude_fields {
			local_var_req_builder = local_var_req_builder.query(&[("exclude_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_full_fields {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_full_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_affix_num_tokens {
			local_var_req_builder =
				local_var_req_builder.query(&[("highlight_affix_num_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_start_tag {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_start_tag", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_end_tag {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_end_tag", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_highlight_v1 {
			local_var_req_builder = local_var_req_builder.query(&[("enable_highlight_v1", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = snippet_threshold {
			local_var_req_builder = local_var_req_builder.query(&[("snippet_threshold", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = drop_tokens_threshold {
			local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_threshold", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = drop_tokens_mode {
			local_var_req_builder = local_var_req_builder.query(&[("drop_tokens_mode", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = typo_tokens_threshold {
			local_var_req_builder = local_var_req_builder.query(&[("typo_tokens_threshold", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_typos_for_alpha_numerical_tokens {
			local_var_req_builder =
				local_var_req_builder.query(&[("enable_typos_for_alpha_numerical_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = filter_curated_hits {
			local_var_req_builder = local_var_req_builder.query(&[("filter_curated_hits", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_synonyms {
			local_var_req_builder = local_var_req_builder.query(&[("enable_synonyms", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = synonym_prefix {
			local_var_req_builder = local_var_req_builder.query(&[("synonym_prefix", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = synonym_num_typos {
			local_var_req_builder = local_var_req_builder.query(&[("synonym_num_typos", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = pinned_hits {
			local_var_req_builder = local_var_req_builder.query(&[("pinned_hits", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = hidden_hits {
			local_var_req_builder = local_var_req_builder.query(&[("hidden_hits", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = override_tags {
			local_var_req_builder = local_var_req_builder.query(&[("override_tags", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = highlight_fields {
			local_var_req_builder = local_var_req_builder.query(&[("highlight_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = split_join_tokens {
			local_var_req_builder = local_var_req_builder.query(&[("split_join_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = pre_segmented_query {
			local_var_req_builder = local_var_req_builder.query(&[("pre_segmented_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = preset {
			local_var_req_builder = local_var_req_builder.query(&[("preset", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_overrides {
			local_var_req_builder = local_var_req_builder.query(&[("enable_overrides", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prioritize_exact_match {
			local_var_req_builder = local_var_req_builder.query(&[("prioritize_exact_match", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = max_candidates {
			local_var_req_builder = local_var_req_builder.query(&[("max_candidates", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prioritize_token_position {
			local_var_req_builder =
				local_var_req_builder.query(&[("prioritize_token_position", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = prioritize_num_matching_fields {
			local_var_req_builder =
				local_var_req_builder.query(&[("prioritize_num_matching_fields", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = enable_typos_for_numerical_tokens {
			local_var_req_builder =
				local_var_req_builder.query(&[("enable_typos_for_numerical_tokens", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = exhaustive_search {
			local_var_req_builder = local_var_req_builder.query(&[("exhaustive_search", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = search_cutoff_ms {
			local_var_req_builder = local_var_req_builder.query(&[("search_cutoff_ms", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = use_cache {
			local_var_req_builder = local_var_req_builder.query(&[("use_cache", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = cache_ttl {
			local_var_req_builder = local_var_req_builder.query(&[("cache_ttl", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = min_len_1typo {
			local_var_req_builder = local_var_req_builder.query(&[("min_len_1typo", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = min_len_2typo {
			local_var_req_builder = local_var_req_builder.query(&[("min_len_2typo", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = vector_query {
			local_var_req_builder = local_var_req_builder.query(&[("vector_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = remote_embedding_timeout_ms {
			local_var_req_builder =
				local_var_req_builder.query(&[("remote_embedding_timeout_ms", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = remote_embedding_num_tries {
			local_var_req_builder =
				local_var_req_builder.query(&[("remote_embedding_num_tries", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_strategy {
			local_var_req_builder = local_var_req_builder.query(&[("facet_strategy", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = stopwords {
			local_var_req_builder = local_var_req_builder.query(&[("stopwords", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = facet_return_parent {
			local_var_req_builder = local_var_req_builder.query(&[("facet_return_parent", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = voice_query {
			local_var_req_builder = local_var_req_builder.query(&[("voice_query", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = conversation {
			local_var_req_builder = local_var_req_builder.query(&[("conversation", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = conversation_model_id {
			local_var_req_builder = local_var_req_builder.query(&[("conversation_model_id", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_str) = conversation_id {
			local_var_req_builder = local_var_req_builder.query(&[("conversation_id", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<SearchCollectionError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Update an individual document from a collection by using its ID. The
	/// update can be partial.
	async fn update_document(&self, params: UpdateDocumentParams) -> Result<serde_json::Value, Error<UpdateDocumentError>> {
		let UpdateDocumentParams {
			collection_name,
			document_id,
			body,
			dirty_values,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents/{documentId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			documentId = crate::apis::urlencode(document_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = dirty_values {
			local_var_req_builder = local_var_req_builder.query(&[("dirty_values", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&body);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpdateDocumentError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// The filter_by query parameter is used to filter to specify a condition
	/// against which the documents are matched. The request body contains the
	/// fields that should be updated for any documents that match the filter
	/// condition. This endpoint is only available if the Typesense server is
	/// version `0.25.0.rc12` or later.
	async fn update_documents(
		&self,
		params: UpdateDocumentsParams,
	) -> Result<models::UpdateDocuments200Response, Error<UpdateDocumentsError>> {
		let UpdateDocumentsParams {
			collection_name,
			body,
			filter_by,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/documents",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

		if let Some(ref local_var_str) = filter_by {
			local_var_req_builder = local_var_req_builder.query(&[("filter_by", &local_var_str.to_string())]);
		}
		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&body);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpdateDocumentsError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create or update an override to promote certain documents over others.
	/// Using overrides, you can include or exclude specific documents for a
	/// given query.
	async fn upsert_search_override(
		&self,
		params: UpsertSearchOverrideParams,
	) -> Result<models::SearchOverride, Error<UpsertSearchOverrideError>> {
		let UpsertSearchOverrideParams {
			collection_name,
			override_id,
			search_override_schema,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/overrides/{overrideId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			overrideId = crate::apis::urlencode(override_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&search_override_schema);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpsertSearchOverrideError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}

	/// Create or update a synonym  to define search terms that should be
	/// considered equivalent.
	async fn upsert_search_synonym(
		&self,
		params: UpsertSearchSynonymParams,
	) -> Result<models::SearchSynonym, Error<UpsertSearchSynonymError>> {
		let UpsertSearchSynonymParams {
			collection_name,
			synonym_id,
			search_synonym_schema,
		} = params;

		let local_var_configuration = &self.configuration;

		let local_var_client = &local_var_configuration.client;

		let local_var_uri_str = format!(
			"{}/collections/{collectionName}/synonyms/{synonymId}",
			local_var_configuration.base_path,
			collectionName = crate::apis::urlencode(collection_name),
			synonymId = crate::apis::urlencode(synonym_id)
		);
		let mut local_var_req_builder = local_var_client.request(reqwest::Method::PUT, local_var_uri_str.as_str());

		if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
			local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
		}
		if let Some(ref local_var_apikey) = local_var_configuration.api_key {
			let local_var_key = local_var_apikey.key.clone();
			let local_var_value = match local_var_apikey.prefix {
				Some(ref local_var_prefix) => format!("{} {}", local_var_prefix, local_var_key),
				None => local_var_key,
			};
			local_var_req_builder = local_var_req_builder.header("X-TYPESENSE-API-KEY", local_var_value);
		};
		local_var_req_builder = local_var_req_builder.json(&search_synonym_schema);

		let local_var_req = local_var_req_builder.build()?;
		let local_var_resp = local_var_client.execute(local_var_req).await?;

		let local_var_status = local_var_resp.status();
		let local_var_content = local_var_resp.text().await?;

		if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
			serde_json::from_str(&local_var_content).map_err(Error::from)
		} else {
			let local_var_entity: Option<UpsertSearchSynonymError> = serde_json::from_str(&local_var_content).ok();
			let local_var_error = ResponseContent {
				status: local_var_status,
				content: local_var_content,
				entity: local_var_entity,
			};
			Err(Error::ResponseError(local_var_error))
		}
	}
}

/// struct for typed errors of method [`delete_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteDocumentsError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSearchOverrideError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_search_synonym`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteSearchSynonymError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`export_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ExportDocumentsError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetDocumentError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchOverrideError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_overrides`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchOverridesError {
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_synonym`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchSynonymError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_search_synonyms`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetSearchSynonymsError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`import_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ImportDocumentsError {
	Status400(models::ApiResponse),
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`index_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum IndexDocumentError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`multi_search`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum MultiSearchError {
	Status400(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`search_collection`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum SearchCollectionError {
	Status400(models::ApiResponse),
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_document`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_documents`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateDocumentsError {
	Status400(models::ApiResponse),
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upsert_search_override`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpsertSearchOverrideError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upsert_search_synonym`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpsertSearchSynonymError {
	Status404(models::ApiResponse),
	UnknownValue(serde_json::Value),
}
